https://www.youtube.com/watch?v=7EmboKQH8lM

## Element de base

### Structure
Les lignes restent sur un écran (classique) 

Les noms doivent :

* Signifier l'intention
* Plus la fonction est dans un grand scope, plus le nom doit être précis et long (et inversement, dans un for, on peut se permettre d'avoir un i)

### Review

Idéalement, on fait plus de pairing que de code review car on doit mettre presque autant de temps pour faire du code review que pour créer le code (techniquement) et autant partager le travail.

### Ethics

* Un code qui passe en production est un code qualitatif
* A chaque fin d'itération, on a un build possible, qu'on décide de le passer ou pas, il marche. (On peut log-off mais on peut log-in, ça marche! Tout le testing marche, la documentation est la)
* Code qualitatif et on ne prend pas de shortcut pour avoir une productivité en début ou 5 ans apres est similaire.
* Un code doit être facile à changer/remplacer. Le changement est proportonnel à l'échelle du changement. Il ne doit pas avoir de "restrictions" s'il y a des grosses restrictions pour des petits changements c'est qu'il y a a eu des problemes, si ce n'est pas possible, on est dans du hardware
* Le code évolue et s'améliore avec le temps. A chaque fois qu'on passe sur un code, on améliore. Si on a peur de casser, on crée les Unit Testing qui auraient du être la. S'ils sont la, on change et une fois que tous les test sont ok, on passe. (Petit à petit)
* Unit Testing n'est pas censé être remplacé par des QA
* Les test sont censés être automatisés pour pouvoir les faire quand c'est possible car s'il y a toujours les même test pour s'assurer que tout fonctionne, il faut les automatiser (qualitatif)
* Estimations sont honnnêtes fourchettes


## Fonctions

### Mise en page
* Fonction doit être croute (<20 lignes = Top // <100 lignes = Mandatory)
* Plus on descend dans la fonction, plus on peut augmenter les détails
* L'indentation est limité à 1 ou 2 échelle (techniquement)

### Caractéristiques
* Une fonction doit faire une seule chose (C'est le cas quand on ne peut pas extraire une fonction de la fonction)
* Si une fonction peut avoir plus fonctions extraites de cette classe et que ces fonctions partagent des variables, c'est une classe, pas une fonction
* Nombre d'arguments doit etre limité au plus (3-4 est une limite car cela devient compliqué apres et plus dur de lire, s'il y a trop d'arguments car ils sont liés, cela devrait surement être un objet)
* Si duplicat = Fonction (Duplicate ou un peu duplliqué)

### Abstractions
* Le niveau d'abstraction d'une fonction doit etre un niveau en dessous du nom de la fonction (pas completement différent
* Le niveau d'abstraction d'une fonction doit etre similaire sur l'ensemble de son contenu

### Specificité
* Rarement passé des booleans dans une fonction, s'il y a 2 comportements autant faire 2 fonctions (et si c'est un boolean qui est passé d'une fonction à l'autre, faire les 2 comportements quand c'est nécessaire lors du if statement). ça peut aussi avoir une utilité mais dans le cas de logique, cela nuit à la lisibilité.
* Limiter les cas de switch (Cas extrement spécifique, interface plus important) principe d'open-closed (open extension, close for modification) et cela ajoute beaucoup de travail
* No Side Effect- Un Side Effect est le fait de changer l'état du Systeme. Si une fonction fait que le systeme change d'état, elle a un side effect comme File.Open ou New (car elle attribue de la mémoire pour un élément, le systeme change d'état). C'est pour cela que ces fonctions vont par paire (Open & CLose / New & Free/Delete). C'est pour cela qu'on a crée le Garbage Collector.
* Une fonction avec un return ne doit pas avoir de side effect, une fonction avec un void en a, donc les return = safe à use et ça permet de savoir ce qu'est.
* Si une fonction a un try/Catch, c'est la fonction => Try { Do } Catch et potentiellement un finally et c'est la fonction do qui va retourner l'exception, simple et facile, on sort la gestion d'erreur de la logique de la fonction (Fonctionement + Gestion erreur = 2 choses) (Pas de nested try /catch)

## Comments

Les commentaires ne sont pas absolus et vitaux. Les commentaires sont nécessaires mais sont un échecs car cela veut dire que le code n'est pas 100% clair. Il est important de les mettre à jour comme le code car ils peuvent être trompeux. Un commentaire commente le code où il est, pas ailleurs !

Les commentaires ne sont pas là pour compenser un mauvais code, évacuer de la frustration, expliquer l'obvious. Ils sont encore moins là pour un todo (sauf si c'est avant un push pour s'organiser) et si tout est clair, c'est juste une distraction.

Les cas pour faire un commentaire :

* Conditions légales et ressources utilisées
* Expliquer une intention
* Clarification d'un code qui est pas forcement clair pour un humain (genre fonctions mathématiques, grosse conditions,etc)
* Documentation API (mais le but c'est que ça reste lisible dans le code)

## Test Driven Developpment

Idéalement, on développe toujours en suivant 3 règles :

* Toujours faire le test avant d'écrire du code
* Ne pas aller plus loin dans un test des qu'il fail à compile
* Réparer les test des qu'il fail

Cela permet d'être sur que tout marche à tout moment. Cela permet de penser chaque élément et que tout soit mieux penser même si cela ralentit le processus. Cela permet aussi de limiter fortement le débug car chaque élément a été testé et que tout le code soit tester et confirmer.

Les test ne sont pas un systeme, ils sont tous independents et sont des petits snippets de codes qui montrent comment un élément marche et ne sont pas ambigüs. Cela permet aussi d'avoir une tres tres bonne documentation low level.

Cela permet aussi d'éviter d'avoir du code non-testable et qui rend les test moins importants (ils marchent, mais ce n'est plus fiable) et cela rend les test moins chiant et c'est impossible d'avoir un code qui est dur à tester et donc du code interdependant

Le code est une source de documentation où tout doit être correct. Les comptables ont aussi un travail rigoureux où tout doit être correct. Pour s'assurer que tout soit bon, ils ont une discipline en mettant d'un côté les biens et de l'autre les charges (Assets et liablities). Tout doit être equivalent et doit être égal à 0 (double entry booking). En développement, on utilise le même principe avec les Test Unit.

### Mutation Testing

C'est le principe que les test sont mutés avec des changements (ex && devient || ou == devient >= ), la mutation doit être fail, si elle passe, elle est considérée comme vivante car cela veut dire que des erreurs dans le code peut être incorrect sans que cela soit detecté.

Le problème c'est que c'est cher en puissance de calcul, mais c'est bien à executer de temps en temps. Cela permet de trouver plein de petit points dur à trouver.




